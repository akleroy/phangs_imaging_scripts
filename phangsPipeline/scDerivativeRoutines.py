import inspect
import logging

import numpy as np
import astropy.units as u
from astropy.io import fits
from spectral_cube import SpectralCube, Projection

from .pipelineVersion import tableversion, version

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

# &%&%&&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%
# Helper functions
# &%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%


# Force reduction in bit-depth to save space.
def writer(projection, filename, overwrite=True, dtype=np.float32):
    hdu = fits.PrimaryHDU(projection.hdu.data.astype(dtype),
                          header=projection._header)
    hdu.writeto(filename, overwrite=overwrite)


def update_metadata(projection, cube, error=False):

    keys = ['BMAJ', 'BMIN', 'BPA', 'JYTOK', 'VELREF',
            'TELESCOP', 'INSTRUME', 'ORIGIN', 'OBJECT',
            'TIMESYS','MJDREFI','MJDREFF','DATEREF']
    calling_name = inspect.getouterframes(inspect.currentframe())[1][3]
    btype_dict = {'write_moment0':'Moment0',
                  'write_moment1':'Moment1',
                  'write_moment2':'Moment2',
                  'write_ew':'VelDisp EW',
                  'write_tmax':'Tpeak',
                  'write_vmax':'Vmax',
                  'write_vquad':'Vmax',
                  'write_moment1_hybrid':'Moment1'}
    hdr = projection.header
    try:
        btype = btype_dict[calling_name]
        if error:
            btype = btype+' Error'
        hdr['BTYPE'] = btype
    except KeyError:
        btype = 'Product'

    for key in keys:
        try:
            hdr[key] = cube.header[key]
        except KeyError:
            pass

    # Check if the moment map is empty. If so, nanmax and nanmin
    # will not be finite and writing the header to disk will fail.
    if not np.isfinite(projection.filled_data[:].value).any():
        mx = 0.
        mn = 0.
    else:
        ind = np.isfinite(projection.filled_data[:])
        mx =  np.nanmax(projection.filled_data[ind])
        mn =  np.nanmin(projection.filled_data[ind])
        hdr['DATAMAX'] = mx.value
        hdr['DATAMIN'] = mn.value

    if 'moment_axis' in projection.meta.keys():
        idx = projection.meta['moment_axis']
    else:
        idx = 0 # Assume spectral moment

    collapse_name = cube.wcs.axis_type_names[::-1][idx]
    med_spaxis = np.abs(np.median(cube.spectral_axis[1:]
                                  - cube.spectral_axis[0:-1]))
    hdr['CHANWDTH'] = med_spaxis.value
    hdr.comments['CHANWDTH'] = 'Median channel width in {0}'.format(med_spaxis.unit)

    # Eliminate BEAM keyword in favor of BMIN, BMAJ, BPA
    try:
        del hdr['BEAM']
    except KeyError:
        pass

    hdr['COMMENT'] = 'Produced with PHANGS-ALMA pipeline version ' + version
    if tableversion:
        hdr['COMMENT'] = 'Galaxy properties from PHANGS sample table version ' + tableversion
    hdr['COMMENT'] = (btype
                      + ' generated by collapsing cube over '
                      + collapse_name + ' axis.')

    comments = hdr['COMMENT']
    unique_comments = list(set(comments))
    try:
        del hdr['COMMENT']
    except KeyError:
        pass

    for comm in unique_comments:
        hdr.set('COMMENT', comm)

    projection._header = hdr
    return(projection)

def channel_width(cube):
    dv = np.median(np.abs(cube.spectral_axis[1:]
                          - cube.spectral_axis[0:-1]))
    return(dv)

def build_covariance(spectrum=None,
                     rms=None,
                     channel_correlation=None,
                     index=None):
    """
    Build a covariance matrix from a channel_correlation vector

    Keywords:
    ---------

    spectrum : np.array
        One-dimensional array of spectrum values

    rms : np.array
        One-dimensional array containing the root-mean-squared error
        estimate for the values in the spectrum

    channel_correlation : np.array
        One-dimensional array containing the channel-to-channel
        normalize correlation coefficients

    index : np.array
        Integer array indicating the spectral indices of the data
        in the original cube
    """

    # Note that this assumes you are masking out values to make sure
    # arrays stay the same shape as the input

    if index is None:
        index = np.arange(len(spectrum))
    if channel_correlation is None:
        return(np.diag(rms**2))
    if len(channel_correlation) == 1:
        return(np.diag(rms**2))
    distance = np.abs(index[:, np.newaxis] - index[np.newaxis, :])
    covar = rms[:, np.newaxis] * rms[np.newaxis, :]
    maxdist = len(channel_correlation)
    covar[distance >= maxdist] = 0
    covar[distance < maxdist] *= channel_correlation[distance[distance
                                                              < maxdist]]
    return(covar)

def calculate_channel_correlation(cube, length=1):
    """
    TBD - calculate the channel correlation.
    """
    raise NotImplementedError

# &%&%&&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%
# Moment 0
# &%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%

def write_moment0(
        cube, rms=None, channel_correlation=None,
        outfile=None, errorfile=None,
        overwrite=True, unit=None,
        include_limits=True,
        line_width=10 * u.km / u.s,
        return_products=True):

    """Write out moment0 map for a SpectralCube

    Keywords:
    ---------

    cube : SpectralCube
        (Masked) spectral cube to write a moment0 map

    outfile : str
        File name of output file

    errorfile : str
        File name of map for the uncertainty

    rms : SpectralCube
        Root-mean-square estimate of the error.  This must have an estimate
        the noise level at all positions where there is signal, and only at
        those positions.

    channel_correlation : np.array
        One-dimensional array containing the channel-to-channel
        normalize correlation coefficients

    overwrite : bool
        Set to True (the default) to overwrite existing maps if present.

    unit : astropy.Unit
        Preferred unit for moment masks

    include_limits : bool
        If true: For masked lines of sight inside the data, set the
        moment0 value to 0 and the error to a value of 1sigma over
        line_width as specified below.

    line_width : astropy.Quantity
        Assumed line width for moment0 upper limit.  Default = 10 km/s

    return_products : bool
        Return products calculated in the map

    """

    # Spectral cube collapse routine. Applies the masked, automatically
    mom0 = cube.moment0()
    valid = np.isfinite(mom0)
    if include_limits:
        observed = np.any(np.isfinite(cube._data), axis=0)
        mom0[np.logical_and(np.isnan(mom0), observed)] = 0.0

    # Handle the error.
    mom0err_proj = None

    if errorfile is not None and rms is None:
        logger.error("Moment 0 error requested but no RMS provided")

    if rms is not None:
        # Initialize the error map
        mom0err = np.empty(mom0.shape)
        mom0err.fill(np.nan)

        # Note the channel width
        dv = channel_width(cube)
        if include_limits:
            rmsmed = np.nanmedian(rms.filled_data[:].value, axis=0)
            mom0err[observed] = (rmsmed[observed]
                                 * (np.abs(line_width
                                           / dv).to(u.dimensionless_unscaled).value)**0.5)

        # Make a masked version of the noise cube
        rms = rms.with_mask(cube._mask.include(), inherit_mask=False)

        if channel_correlation is None:
            sumofsq = (rms * rms).sum(axis=0)
            mom0err[valid] = np.sqrt(sumofsq[valid])
        else:
            # Iterates over the cube one ray at a time
            yy, xx = np.where(valid)
            for y, x in zip(yy, xx):
                slc = (slice(None), slice(y,y+1,None), slice(x,x+1,None))
                mask = np.squeeze(cube.mask.include(view=slc))
                index = np.where(mask)[0]

                # One dimensional versions of the data and noise
                rms_spec = rms.flattened(slc).value
                spec = cube.flattened(slc).value

                # Build a covariance matrix given the channel correlation
                covar = build_covariance(
                    spectrum=spec, rms=rms_spec,
                    channel_correlation=channel_correlation,
                    index=index)

                # Collapse the covariance matrix into an integrated moment map
                mom0err[y, x] = (np.sum(covar))**0.5

        # Multiply by the channel width and assign correct units
        mom0err = u.Quantity(mom0err * dv.value,
                             cube.unit * dv.unit, copy=False)

        # Convert units if request
        if unit is not None:
            mom0err = mom0err.to(unit)

        # Convert from an array into a spectral-cube projection that
        # shares metadata with the moment map
        mom0err_proj = Projection(
            mom0err, wcs=mom0.wcs, header=mom0.header, meta=mom0.meta)

        # Write to disk if requested
        if errorfile is not None:
            mom0err_proj = update_metadata(mom0err_proj, cube, error=True)
            writer(mom0err_proj, errorfile, overwrite=overwrite)
            # mom0err_proj.write(errorfile, overwrite=overwrite)
    else:
        mom0err_proj = None

    # Convert units if requested
    if unit is not None:
        mom0 = mom0.to(unit)

    # If requested, write to disk
    if outfile is not None:
        mom0 = update_metadata(mom0, cube)
        writer(mom0, outfile, overwrite=overwrite)
        # mom0.write(outfile, overwrite=overwrite)

    # If requested, return
    if return_products:
        return(mom0, mom0err_proj)

# &%&%&&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%
# Moment 1
# &%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%

def write_moment1(
    cube, rms=None, channel_correlation=None,
    outfile=None, errorfile=None,
    overwrite=True, unit=None,
    return_products=True):
    """
    Write out moment1 map for a SpectralCube

    Keywords:
    ---------

    cube : SpectralCube
        (Masked) spectral cube to write a moment1 map

    outfile : str
        File name of output file

    errorfile : str
        File name of map for the uncertainty

    rms : SpectralCube
        Root-mean-square estimate of the error.  This must have an estimate
        the noise level at all positions where there is signal, and only at
        those positions.

    channel_correlation : np.array
        One-dimensional array containing the channel-to-channel
        normalize correlation coefficients

    overwrite : bool
        Set to True (the default) to overwrite existing maps if present.

    unit : astropy.Unit
        Preferred unit for moment masks

    return_products : bool
        Return products calculated in the map
    """

    mom1 = cube.moment1()
    mom1err_proj = None
    spaxis = cube.spectral_axis.value

    if errorfile is not None and rms is None:
        logger.error("Moment 1 error requested but no RMS provided")

    if rms is not None:
        mom1err = np.empty(mom1.shape)
        mom1err.fill(np.nan)
        # Ensure the same mask applied to both.
        rms = rms.with_mask(cube._mask.include(), inherit_mask=False)
        valid = np.isfinite(mom1)

        if channel_correlation is None:
            vval = spaxis
            sum_T = cube.sum(axis=0).value
            numer = np.nansum(rms.filled_data[:].value**2
                              * (vval[:, np.newaxis, np.newaxis]
                                 - mom1.value[np.newaxis, :, :])**2,
                              axis=0)
            mom1err = (numer / sum_T**2)**0.5
            mom1err[np.isnan(mom1.value)] = np.nan
        else:
            yy, xx = np.where(valid)
            for y, x in zip(yy, xx):
                slc = (slice(None), slice(y,y+1,None), slice(x,x+1,None))
                mask = np.squeeze(cube.mask.include(view=slc))
                index = np.where(mask)[0]
                rms_spec = rms.flattened(slc).value
                spec = cube.flattened(slc).value
                covar = build_covariance(spectrum=spec,
                                         rms=rms_spec,
                                         channel_correlation=channel_correlation,
                                         index=index)

                vval = spaxis[index]
                sum_T = np.sum(spec)
                sum_vT = np.sum(spec * vval)

                jacobian = vval / sum_T - sum_vT / sum_T**2
                mom1err[y, x] = np.dot(
                    np.dot(jacobian[np.newaxis, :], covar),
                    jacobian[:, np.newaxis])**0.5
        mom1err = u.Quantity(mom1err, cube.spectral_axis.unit, copy=False)
        if unit is not None:
            mom1err = mom1err.to(unit)
        mom1err_proj = Projection(mom1err,
                                  wcs=mom1.wcs,
                                  header=mom1.header,
                                  meta=mom1.meta)
        if errorfile is not None:
            mom1err_proj = update_metadata(mom1err_proj, cube, error=True)
            writer(mom1err_proj, errorfile, overwrite=overwrite)
            # mom1err_proj.write(errorfile, overwrite=overwrite)

    if unit is not None:
        mom1 = mom1.to(unit)
    if outfile is not None:
        mom1 = update_metadata(mom1, cube)
        writer(mom1, outfile, overwrite=overwrite)
        # mom1.write(outfile, overwrite=True)

    if return_products and mom1err_proj is not None:
        return(mom1, mom1err_proj)
    elif return_products and mom1err_proj is None:
        return(mom1)


def convert_and_reproject(name, template=None, unit=None, order=1):
    """
    Helper for moment1 hybrid routine. Reads in data, makes sure it is
    a projection, converts units, and reprojects as necessary.
    """

    # Ensure inputs are Projections
    if name is not None:
        if type(name) is Projection:
            data = name
        elif type(name) is str:
            hdu_list = fits.open(name)
            data = Projection.from_hdu(hdu_list[0])
        else:
            print("Input is not a string or a Projection")
            raise ValueError

        if unit is not None:
            data = data.to(unit)
        if template is not None:
            data = data.reproject(template.header, order=order)
    else:
        data = None

    return(data)

def write_moment1_hybrid(
    cube, rms=None, channel_correlation=None,
    outfile=None, errorfile=None,
    overwrite=True, unit=None,
    return_products=True,
    strict_mom1=None,
    strict_emom1=None,
    broad_mom1=None,
    broad_emom1=None,
    broad_mom0=None,
    broad_emom0=None,
    vfield_prior=None,
    vfield_reject_thresh='30km/s',
    mom0_thresh=2.0,
    context=None):
    """Write out moment1 map using combination of other moment maps.
    This is a secondary moment that needs to be calculated in the
    context of other moments.

    Keywords:
    ---------

    cube : SpectralCube
        Included to keep same call signature but not used

    rms : SpectralCube
        Included to keep the same call signature but not used.

    channel_correlation : np.array
        Included to keep the same call signature but not used.

    outfile : str
        File name of output file

    errorfile : str
        File name of map for the uncertainty

    overwrite : bool
        Set to True (the default) to overwrite existing maps if present.

    unit : astropy.Unit
        Preferred unit for moment masks

    return_products : bool
        Return products calculated in the map

    strict_mom1 : str
        Moment tag for velocity field to be used as a high confidence map

    broad_mom1 : str
        Moment tag for velocity field for low confidence map

    broad_mom0 : str
        Moment tag to be used as an estimate of the signal for a S/N
        cut on where the broad_mom1 is valid.  Also finds a noise
        estimate of the same and uses this for the Noise component

    vfield_prior : str
        Moment tag for low-resolution prior map of velocity field

    vfield_reject_thresh : astropy.units.Quantity
        The maximum difference between the broad field and the prior
        field in units that can convert to that of the velocity field.

     mom0_thresh : float
        S/N threshold for using a broad_mom0 estimate in the map
    """

    # -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    # Read in and align the data and tuning parameters
    # -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

    # The threshold for outlier rejection from the prior velocity field
    vfield_reject_thresh = u.Quantity(vfield_reject_thresh)

    # Read the high confidence velocity map and error
    mom1strict = convert_and_reproject(strict_mom1, unit=unit)
    mom1strict_error = convert_and_reproject(strict_emom1, unit=unit)

    # Read the intensity map to be used as a prior
    mom0broad = convert_and_reproject(broad_mom0, template=mom1strict)
    mom0broad_error = convert_and_reproject(broad_emom0, template=mom1strict)

    # This broad moment 1 map will be used as a candidate velocity field
    mom1broad = convert_and_reproject(
        broad_mom1, template=mom1strict, unit=unit)
    mom1broad_error = convert_and_reproject(
        broad_emom1, template=mom1strict, unit=unit)

    # This prior velocity field will be used to reject outliers
    mom1prior = convert_and_reproject(
        vfield_prior, template=mom1strict, unit=unit)

    # -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    # Hybridize the low and high confidence moment maps
    # -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

    # Start with the high quality strict mask
    mom1hybrid = mom1strict.value

    # Candidate entries are places with a broad value
    valid_broad_mom1 = np.isfinite(mom1broad.value)

    # ... but not any strict value
    valid_broad_mom1[np.isfinite(mom1strict)] = False

    # If thresholding on intensity, apply that cut:
    if (mom0broad is not None):

        if (mom0broad_error is not None):
            # ... either as signal-to-noise
            valid_broad_mom1 *= \
                (mom0broad.value > (mom0_thresh* mom0broad_error.value))
        else:
            # ... or a simple intensity cut
            valid_broad_mom1 *= \
                (mom0broad.value > mom0_thresh)

    # Thresholding on offset from vfield prior
    if mom1prior is not None:

        valid_broad_mom1 = (valid_broad_mom1 *
                            (np.abs(mom1broad - mom1prior)
                             < vfield_reject_thresh)
                            )

    # Fill in the still-valid locations in the hybrid
    mom1hybrid[valid_broad_mom1] = (mom1broad.value)[valid_broad_mom1]
    mom1hybrid = u.Quantity(mom1hybrid, unit)
    if unit is not None:
        mom1hybrid = mom1hybrid.to(unit)

    # -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    # Attach to WCS and write to disk
    # -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

    # Attach to WCS
    mom1hybrid_proj = Projection(mom1hybrid,
                                 wcs=mom1strict.wcs,
                                 header=mom1strict.header,
                                 meta=mom1strict.meta)

    # Write to disk
    if outfile is not None:
        writer(mom1hybrid_proj, outfile, overwrite=overwrite)
        # mom1hybrid_proj.write(outfile,
        #                      overwrite=overwrite)

    # -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    # Propagate errors from the input map to an error map
    # -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

    mom1hybrid_error_proj = None

    print(type(mom1broad_error), type(mom1strict_error))

    if (type(mom1broad_error) is Projection and
        type(mom1strict_error) is Projection):

        mom1hybrid_error = mom1broad_error
        mom1hybrid_error[~np.isfinite(mom1hybrid.value)] = np.nan

        strictvals = np.isfinite(mom1strict_error.value)
        mom1hybrid_error[strictvals] = mom1strict_error[strictvals]

        if unit is not None:
            mom1hybrid_error = mom1hybrid_error.to(unit)

        mom1hybrid_error_proj = Projection(mom1hybrid_error,
                                           wcs=mom1strict.wcs,
                                           header=mom1strict.header,
                                           meta=mom1strict.meta)

        if errorfile is not None:
            mom1hybrid_error_proj = update_metadata(mom1hybrid_error_proj,
                                                    cube, error=True)
            writer(mom1hybrid_error_proj, errorfile, overwrite=overwrite)
            # mom1hybrid_error_proj.write(errorfile,
            #                            overwrite=overwrite)

    # -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    # Return if requested
    # -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

    if return_products:
        if mom1hybrid_error_proj is not None:
            return(mom1hybrid_proj, mom1hybrid_error_proj)
        elif mom1hybrid_error_proj is None:
            return(mom1hybrid_proj)

    return()

# &%&%&&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%
# Moment 2
# &%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%

def write_moment2(
    cube, rms=None, channel_correlation=None,
    outfile=None, errorfile=None,
    overwrite=True, unit=None,
    return_products=True):
    """
    Write out linewidth (moment2-based) map for a SpectralCube

    Keywords:
    ---------

    cube : SpectralCube
        (Masked) spectral cube to write a Moment 2 (velocity
        dispersion) map

    outfile : str
        File name of output file

    errorfile : str
        File name of map for the uncertainty

    rms : SpectralCube
        Root-mean-square estimate of the error.  This must have an estimate
        the noise level at all positions where there is signal, and only at
        those positions.

    channel_correlation : np.array
        One-dimensional array containing the channel-to-channel
        normalize correlation coefficients

    overwrite : bool
        Set to True (the default) to overwrite existing maps if present.

    unit : astropy.Unit
        Preferred unit for moment masks

    return_products : bool
        Return products calculated in the map
    """

    mom2 = cube.linewidth_sigma()
    spaxis = cube.spectral_axis.value

    if errorfile is not None and rms is None:
        logger.error("Moment 2 error requested but no RMS provided")

    if rms is not None:

        mom2err = np.empty(mom2.shape)
        mom2err.fill(np.nan)
        rms = rms.with_mask(cube._mask.include(), inherit_mask=False)
        valid = np.isfinite(mom2)

        if channel_correlation is None:
            sum_T = cube.sum(axis=0).value
            mom1 = cube.moment1().value
            vval = spaxis
            numer = np.nansum(rms.filled_data[:].value**2
                              * ((vval[:, np.newaxis, np.newaxis]
                                  - mom1[np.newaxis, :, :])**2
                                 - (mom2.value)[np.newaxis, :, :]**2)**2,
                              axis=0)
            mom2err = (numer / sum_T**2)**0.25
        else:
            yy, xx = np.where(valid)
            for y, x in zip(yy, xx):
                slc = (slice(None), slice(y,y+1,None), slice(x,x+1,None))
                mask = np.squeeze(cube.mask.include(view=slc))
                index = np.where(mask)[0]

                rms_spec = rms.flattened(slc).value
                spec = cube.flattened(slc).value
                covar = build_covariance(spectrum=spec,
                                         rms=rms_spec,
                                         channel_correlation=channel_correlation,
                                         index=index)

                vval = spaxis[index]
                sum_T = np.sum(spec)
                sum_vT = np.sum(spec * vval)
                vbar = sum_vT / sum_T
                vdisp = (vval - vbar)**2
                wtvdisp = np.sum(spec * vdisp)
                # Dear future self: There is no crossterm (error term from
                # vbar) since dispersion is at a minimum around vbar
                jacobian = (vdisp / sum_T
                            - wtvdisp / sum_T**2)
                mom2err[y, x] = np.dot(
                    np.dot(jacobian[np.newaxis, :], covar),
                    jacobian[:, np.newaxis])**0.25
        mom2err = u.Quantity(mom2err, cube.spectral_axis.unit, copy=False)
        if unit is not None:
            mom2err = mom2err.to(unit)
        mom2err_proj = Projection(mom2err,
                                  wcs=mom2.wcs,
                                  header=mom2.header,
                                  meta=mom2.meta)
        if errorfile is not None:
            mom2err_proj = update_metadata(mom2err_proj, cube, error=True)
            writer(mom2err_proj, errorfile, overwrite=overwrite)
            # mom2err_proj.write(errorfile, overwrite=overwrite)

    if unit is not None:
        mom2 = mom2.to(unit)
    if outfile is not None:
        mom2 = update_metadata(mom2, cube)
        writer(mom2, outfile, overwrite=overwrite)
        # mom2.write(outfile, overwrite=True)

    if return_products and mom2err_proj is not None:
        return(mom2, mom2err_proj)
    elif return_products and mom2err_proj is None:
        return(mom2)

def write_ew(cube,
             outfile=None,
             errorfile=None,
             rms=None,
             channel_correlation=None,
             overwrite=True,
             unit=None,
             return_products=True):
    """
    Write out linewidth (equivalent-width-based) map for a SpectralCube

    Keywords:
    ---------

    cube : SpectralCube
        (Masked) spectral cube to write a EW-based velocity dispersion map

    outfile : str
        File name of output file

    errorfile : str
        File name of map for the uncertainty

    rms : SpectralCube
        Root-mean-square estimate of the error.  This must have an estimate
        the noise level at all positions where there is signal, and only at
        those positions.

    channel_correlation : np.array
        One-dimensional array containing the channel-to-channel
        normalize correlation coefficients

    overwrite : bool
        Set to True (the default) to overwrite existing maps if present.

    unit : astropy.Unit
        Preferred unit for moment masks

    return_products : bool
        Return products calculated in the map
    """

    maxmap = cube.max(axis=0)
    mom0 = cube.moment0()
    sigma_ew = mom0 / maxmap / np.sqrt(2 * np.pi)
    spaxis = cube.spectral_axis.value

    if errorfile is not None and rms is None:
        logger.error("Equivalent width error requested but no RMS provided")
    sigma_ewerr_projection = None
    if rms is not None:
        argmaxmap = cube.argmax(axis=0)
        rms_at_max = np.take_along_axis(
            rms.filled_data[:],
            argmaxmap[np.newaxis, :, :], 0).value


        sigma_ew_err = np.empty(sigma_ew.shape)
        sigma_ew_err.fill(np.nan)
        rms = rms.with_mask(cube._mask.include(), inherit_mask=False)
        dv = np.abs(spaxis[1] - spaxis[0])

        if channel_correlation is None:

            term1 = (np.nansum((rms.filled_data[:].value)**2, axis=0) * dv**2
                     / (2 *np.pi * maxmap.value**2))
            term2 = (sigma_ew.value**2
                     - sigma_ew.value * dv / np.sqrt(2*np.pi)) * np.squeeze(rms_at_max)**2
            sigma_ew_err = (term1 + term2)**0.5

        else:
            yy, xx = np.where(np.isfinite(sigma_ew))
            for y, x in zip(yy, xx):
                slc = (slice(None), slice(y,y+1,None), slice(x,x+1,None))
                mask = np.squeeze(cube.mask.include(view=slc))
                index = np.where(mask)[0]
                rms_spec = rms.flattened(slc).value
                spec = cube.flattened(slc).value
                covar = build_covariance(spectrum=spec,
                                         rms=rms_spec,
                                         channel_correlation=channel_correlation,
                                         index=index)
                sigma_ew_err[y, x] = (np.sum(covar) * dv**2
                                      / (2 * np.pi * maxmap[y, x].value**2)
                                      + (sigma_ew[y, x].value**2
                                         - sigma_ew[y, x].value * dv / np.sqrt(2 * np.pi))
                                      * rms_at_max[0, y, x]**2)**0.5

        sigma_ew_err = u.Quantity(sigma_ew_err,
                                  cube.spectral_axis.unit, copy=False)
        if unit is not None:
            sigma_ew_err = sigma_ew_err.to(unit)

        sigma_ewerr_projection = Projection(sigma_ew_err,
                                            wcs=sigma_ew.wcs,
                                            header=sigma_ew.header,
                                            meta=sigma_ew.meta)

        if outfile is not None:
            sigma_ewerr_projection = update_metadata(
                sigma_ewerr_projection, cube, error=True)
            writer(sigma_ewerr_projection, errorfile, overwrite=overwrite)
            # sigma_ewerr_projection.write(errorfile, overwrite=overwrite)

    # Do the conversion here to not mess up errors in units.
    if unit is not None:
        sigma_ew = sigma_ew.to(unit)
    if outfile is not None:
        sigma_ew = update_metadata(sigma_ew, cube)
        writer(sigma_ew, outfile, overwrite=overwrite)
        # sigma_ew.write(outfile, overwrite=True)

    if return_products and sigma_ewerr_projection is not None:
        return(sigma_ew, sigma_ewerr_projection)
    elif return_products and sigma_ewerr_projection is None:
        return(sigma_ew)

# &%&%&&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%
# Peak temperature
# &%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%

def write_tmax(cubein,
               outfile=None,
               errorfile=None,
               rms=None,
               channel_correlation=None,
               overwrite=True,
               unit=None,
               window=None,
               return_products=True):
    """
    Write out Tmax map for a SpectralCube

    Keywords:
    ---------

    cube : SpectralCube
        (Masked) spectral cube to write a Tmax map

    outfile : str
        File name of output file

    errorfile : str
        File name of map for the uncertainty

    rms : SpectralCube
        Root-mean-square estimate of the error.  This must have an estimate
        the noise level at all positions where there is signal, and only at
        those positions.

    channel_correlation : np.array
        One-dimensional array containing the channel-to-channel
        normalize correlation coefficients

    overwrite : bool
        Set to True (the default) to overwrite existing maps if present.

    unit : astropy.Unit
        Preferred unit for moment masks

    window : astropy.Quantity
        Spectral window over which the data should be smoothed

    return_products : bool
        Return products calculated in the map
    """

    # hack the mask to span the spectral range of the mask but lose spatial information.

    mask = cubein.get_mask_array()
    mask_spec = np.any(mask, axis=(1,2))
    lo = np.min(np.where(mask_spec))
    hi = np.max(np.where(mask_spec))
    mask = np.zeros_like(mask,dtype='bool')
    mask[lo:hi,:,:] = True
    mask *= np.isfinite(cubein.unmasked_data[:])
    new_cube = cubein.with_mask(mask, inherit_mask=False)

    # spectral smoothing if desired

    if window is not None:
        window = u.Quantity(window)

        from astropy.convolution import Box1DKernel
        dv = channel_width(new_cube)
        nChan = (window / dv).to(u.dimensionless_unscaled).value
        if nChan > 1:
            cube = new_cube.spectral_smooth(Box1DKernel(nChan))
            rmsfac = 1/np.sqrt(nChan)
        else:
            cube = new_cube
            rmsfac = 1.0
    else:
        cube = new_cube
        rmsfac = 1.0

    maxmap = cube.max(axis=0)

    if errorfile is not None and rms is None:
        logger.error("Tmax error requested but no RMS provided")

    if rms is not None:
        argmaxmap = cube.argmax(axis=0)
        rms = rms.with_mask(cube._mask.include(), inherit_mask=False)

        rms_at_max = np.take_along_axis(
            rms.filled_data[:],
            argmaxmap[np.newaxis, :, :], 0).value
        # rmsfac accounts for smoothing leading to reduction in rms
        # assuming channels are (nearly) independent
        rms_at_max = np.squeeze(rms_at_max) * rmsfac
        rms_at_max = u.Quantity(rms_at_max, cube.unit, copy=False)
        if unit is not None:
            rms_at_max = rms_at_max.to(unit)
        tmaxerr_projection = Projection(rms_at_max,
                                        wcs=maxmap.wcs,
                                        header=maxmap.header,
                                        meta=maxmap.meta)
        if errorfile is not None:
            tmaxerr_projection = update_metadata(tmaxerr_projection, cube,
                                                 error=True)
            writer(tmaxerr_projection, errorfile, overwrite=overwrite)
            # tmaxerr_projection.write(errorfile, overwrite=overwrite)

    if unit is not None:
        maxmap = maxmap.to(unit)
    if outfile is not None:
        maxmap = update_metadata(maxmap, cube)
        writer(maxmap, outfile, overwrite=overwrite)
        # maxmap.write(outfile, overwrite=True)

    if return_products and tmaxerr_projection is not None:
        return(maxmap, tmaxerr_projection)
    elif return_products and tmaxerr_projection is None:
        return(maxmap)

# &%&%&&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%
# Velocity at peak
# &%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%

def write_vmax(cubein,
               outfile=None,
               errorfile=None,
               rms=None,
               channel_correlation=None,
               overwrite=True,
               unit=None,
               window=None,
               return_products=True):
    """
    Write out velocity map at max brightness temp for a SpectralCube

    Keywords:
    ---------

    cube : SpectralCube
        (Masked) spectral cube to write a Vmax map

    outfile : str
        File name of output file

    errorfile : str
        File name of map for the uncertainty

    rms : SpectralCube
        Root-mean-square estimate of the error.  This must have an estimate
        the noise level at all positions where there is signal, and only at
        those positions.

    channel_correlation : np.array
        One-dimensional array containing the channel-to-channel
        normalize correlation coefficients

    overwrite : bool
        Set to True (the default) to overwrite existing maps if present.

    unit : astropy.Unit
        Preferred unit for moment masks

    window : astropy.Quantity
        Spectral window over which the data should be smoothed

    return_products : bool
        Return products calculated in the map
    """
    if type(window) is u.Quantity:
        from astropy.convolution import Box1DKernel
        dv = channel_width(cube)
        nChan = (window / dv).to(u.dimensionless_unscaled).value
        if nChan > 1:
            cube = cubein.spectral_smooth(Box1DKernel(nChan))
        else:
            cube = cubein
    else:
        cube = cubein
    maxmap = cube.max(axis=0)
    argmaxmap = cube.argmax(axis=0)
    vmaxmap = np.take_along_axis(cube.spectral_axis[:, np.newaxis, np.newaxis],
                                 argmaxmap[np.newaxis, :, :], 0)
    vmaxmap = np.squeeze(vmaxmap)

    vmaxmap[~np.isfinite(maxmap)] = np.nan

    if errorfile is not None and rms is None:
        logger.error("Moment 2 error requested but no RMS provided")

    if rms is not None:
        dv = channel_width(cube)
        vmaxerror = np.empty(maxmap.shape)
        vmaxerror.fill(np.nan)
        vmaxerror[np.isfinite(maxmap)] = dv.value
        vmaxerror = u.Quantity(vmaxerror, dv.unit, copy=False)
        if unit is not None:
            vmaxerror = vmaxerror.to(unit)
        vmaxerr_projection = Projection(vmaxerror,
                                        wcs=maxmap.wcs,
                                        header=maxmap.header,
                                        meta=maxmap.meta)
        if errorfile is not None:
            vmaxerr_projection = update_metadata(vmaxerr_projection, cube,
                                                 error=True)
            writer(vmaxerr_projection, errorfile, overwrite=overwrite)
            # vmaxerr_projection.write(errorfile, overwrite=overwrite)

    vmaxmap = u.Quantity(vmaxmap, cube.spectral_axis.unit)
    if unit is not None:
        vmaxmap = vmaxmap.to(unit)
    vmaxmap_projection = Projection(vmaxmap,
                                    wcs=maxmap.wcs,
                                    header=maxmap.header,
                                    meta=maxmap.meta)

    if outfile is not None:
        vmaxmap_projection = update_metadata(vmaxmap_projection, cube)
        writer(vmaxmap_projection, outfile, overwrite=overwrite)
        # vmaxmap_projection.write(outfile, overwrite=True)

    if return_products and vmaxerr_projection is not None:
        return(vmaxmap_projection, vmaxerr_projection)
    elif return_products and vmaxerr_projection is None:
        return(vmaxmap_projection)

# &%&%&&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%
# Interpolated velocity at peak
# &%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%

def write_vquad(cubein,
                outfile=None,
                errorfile=None,
                rms=None,
                channel_correlation=None,
                overwrite=True,
                unit=None,
                window=None,
                maxshift=0.5,
                return_products=True):
    """
    Write out velocity map at max brightness temp for a
    SpectralCube using the quadratic peak interpolation

    Keywords:
    ---------

    cube : SpectralCube
        (Masked) spectral cube to write a Vmax map

    outfile : str
        File name of output file

    errorfile : str
        File name of map for the uncertainty

    rms : SpectralCube
        Root-mean-square estimate of the error.  This must have an estimate
        the noise level at all positions where there is signal, and only at
        those positions.

    channel_correlation : np.array
        One-dimensional array containing the channel-to-channel
        normalize correlation coefficients

    overwrite : bool
        Set to True (the default) to overwrite existing maps if present.

    unit : astropy.Unit
        Preferred unit for moment masks

    window : astropy.Quantity
        Spectral window over which the data should be smoothed

    maxshift : float
        Maximum number of channels that the algorithm can shift the
        peak estimator (default = 0.5).  Set to None to suppress clipping.

    return_products : bool
        Return products calculated in the map
    """

    from scipy.interpolate import interp1d

    if type(window) is u.Quantity:
        from astropy.convolution import Box1DKernel
        dv = channel_width(cubein)
        nChan = (window / dv).to(u.dimensionless_unscaled).value
        if nChan > 1:
            cube = cubein.spectral_smooth(Box1DKernel(nChan))
        else:
            cube = cubein
    else:
        cube = cubein

    spaxis = cube.spectral_axis.value
    pixinterp = interp1d(np.arange(spaxis.size),
                         spaxis)
    maxmap = cube.max(axis=0)
    argmaxmap = cube.argmax(axis=0)
    argmaxmap = np.clip(argmaxmap, 1, cube.shape[0]-2)
    Tup = np.take_along_axis(cube.filled_data[:],
                             argmaxmap[np.newaxis, :, :]+1, 0).value
    Tdown = np.take_along_axis(cube.filled_data[:],
                               argmaxmap[np.newaxis, :, :]-1, 0).value
    Tup = np.squeeze(np.nan_to_num(Tup))
    Tup[Tup < 0] = 0
    Tdown = np.squeeze(np.nan_to_num(Tdown))
    Tdown[Tdown < 0] = 0

    delta = -1 * ((Tup - Tdown) / (Tup + Tdown - 2 * maxmap.value))
    if maxshift is not None:
        delta = np.clip(delta, -maxshift, maxshift)
    peakchan = argmaxmap + delta

    vmaxmap = np.empty(maxmap.shape)
    vmaxmap.fill(np.nan)
    good = np.isfinite(maxmap)
    vmaxmap[good] = u.Quantity(pixinterp(peakchan[good]),
                               unit)

    vmaxmap[~np.isfinite(maxmap)] = np.nan

    if errorfile is not None and rms is None:
        logger.error("Vquad error requested but no RMS provided")

    if rms is not None:
        rms = rms.with_mask(cube._mask.include(), inherit_mask=False)

        dv = channel_width(cube)
        RMSup = np.take_along_axis(rms.filled_data[:],
                                   argmaxmap[np.newaxis, :, :]+1,
                                   0).value
        RMSdown = np.take_along_axis(rms.filled_data[:],
                                     argmaxmap[np.newaxis, :, :]-1,
                                     0).value
        RMSmax = np.take_along_axis(rms.filled_data[:],
                                    argmaxmap[np.newaxis, :, :],
                                    0).value
        denom = (Tup + Tdown - 2 * maxmap.value)
        j1 = (1/denom - (Tup - Tdown) / denom**2)
        j2 = (2 * (Tup - Tdown) / denom**2)
        j3 = (-1/denom - (Tup - Tdown) / denom**2)
        jacobian = np.r_[j1[np.newaxis, :, :],
                         j2[np.newaxis, :, :],
                         j3[np.newaxis, :, :]]
        if ((channel_correlation is None)
            or len(channel_correlation) == 1):
            covar = np.r_[RMSup,
                          RMSmax,
                          RMSdown]
            covar = covar**2
            error = np.einsum('i...,i...', jacobian**2, covar)
        else:
            if len(channel_correlation) == 2:
                ccor = np.r_[channel_correlation,
                             np.array([0])]
            else:
                ccor = channel_correlation[0:3]
            corrmat = ccor[np.array([[0, 1, 2],
                                     [1, 0, 1],
                                     [2, 1, 0]])]
            rmsvec = np.r_[RMSup,
                           RMSmax,
                           RMSdown]
            # They never should have taught me how to do this.
            covar  = np.einsum('ij,ilm,jlm->ijlm', corrmat,
                               rmsvec, rmsvec)
            error = np.einsum('ilm,jlm,ijlm->lm',
                              jacobian, jacobian, covar)
        if maxshift is not None:
            error = np.clip(error, -maxshift, maxshift)
        vquaderr = error * dv
        if unit is not None:
            vquaderr = vquaderr.to(unit)

        vquaderr_projection = Projection(vquaderr,
                                         wcs=maxmap.wcs,
                                         header=maxmap.header,
                                         meta=maxmap.meta)
        if errorfile is not None:
            vquaderr_projection = update_metadata(vquaderr_projection, cube,
                                                  error=True)
            writer(vquaderr_projection, errorfile, overwrite=overwrite)
            # vquaderr_projection.write(errorfile, overwrite=overwrite)

    vmaxmap = u.Quantity(vmaxmap, cube.spectral_axis.unit)
    if unit is not None:
        vmaxmap = vmaxmap.to(unit)
    vmaxmap_projection = Projection(vmaxmap,
                                    wcs=maxmap.wcs,
                                    header=maxmap.header,
                                    meta=maxmap.meta)
    if outfile is not None:
        vmaxmap_projection = update_metadata(vmaxmap_projection, cube)
        writer(vmaxmap_projection, outfile, overwrite=overwrite)
        # vmaxmap_projection.write(outfile, overwrite=overwrite)

    if return_products and vquaderr_projection is not None:
        return(vmaxmap_projection, vquaderr_projection)
    elif return_products and vquaderr_projection is None:
        return(vmaxmap_projection)
